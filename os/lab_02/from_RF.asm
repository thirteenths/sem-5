.586P               ;Разрешение трансляции всех команд Pentium
;Структура для описания дескрипторов сегментов

descr   struc       ;(2)Начало объявления структуры
lim     dw 0        ;(3)Граница (биты 0..15)
base_1  dw 0        ;(4)База, биты 0..15
base_m  db 0        ;(5)База, биты 0..23
attr_1  db 0        ;(6)Байт атрибутов 1
attr_2  db 0        ;(7)Граница (биты 16..19) и атрибуты 2
base_h  db 0        ;(8)База, биты 24..31
descr   ends        ;(9)Конец объявления структуры

;Сегмент данных
data    segment use16  ;(10)16-разрядный сегмент
;Таблица глобальных дескрипторов GDT
gdt_null    descr   <0,0,0,0,0,0>                           ;(11)Селектор 0, нулевой дескриптор
gdt_data    descr   <data_size-1, 0, 0, 92h, 0, 0>          ;(12)Селектор 8, сегмент данных
gdt_code    descr   <code_size-1, 0, 0, 98h, 0, 0>          ;(13)Селектор 16, сегмент команд
gdt_stack   descr   <255, 0, 0, 92h, 0, 0>                  ;(14)Селектор 24, сегмент стека
gdt_screen  descr   <3999, 8000h, 0Bh, 92h, 0, 0>           ;(15)Селектор 32, видеопамять
gdt_size=$-gdt_null                                         ;(16)Размер GDT
;Различные данные программы

pdescr  df 0                                                            ;(17)Псевдодескриптор для команды lgdt
sym     db 1                                                            ;(18)Символ для вывода на экран
attr    db 1Eh                                                          ;(19)Его атрибут
msg     db 27,'[31  42m Return в реальный режим! ',27,'[0m$'        ;(20)
data_size=$-gdt_null                                                    ;(21)Размер сегмента данных
data ends

;Сегмент команд
text    segment use16              ;(23) 16-разрядный сегмент
        assume CS:text, DS:data     
main    proc
        xor EAX, EAX                ;(26)Очистка EAX
        mov AX, data                ;(27)Загрузка в DS сегментный
        mov DS, AX                  ;(28)адрес сегмента данных
;Вычислим 32-битный линейный адрес сегмента данных и загрузим его
;в дескриптор сегмента данных в таблице глобальных дескрипторов GDT
        shl EAX, 4                  ;EAX=линейный базовый адрес
        mov EBP, EAX                ;Сохраним его в EBP для будущего
        mov BX, offset gdt_data     ;(31)BX=смещение дескриптора
        mov [BX].base_1, AX         ;(32)Загрузим младшую часть базы
        shr EAX, 16                 ;(33)Старшую половину EAX в AX
        mov [BX].base_m, AL         ;(34)Загрузим среднюю часть базы
;Вычислим и загрузим в GDT линейный адрес сегмента команд
        xor EAX, EAX                ;(35) Очистим EAX
        mov AX, CS                  ;(36)Сегментный адрес сегмента команд
        shl EAX, 4
        mov BX, offset gdt_code
        mov [BX].base_1, AX
        shr EAX, 16
        mov [BX].base_m, AL
;Вычислим и загрузим в GDT линейный адрес сегмента стека
        xor EAX, EAX
        mov AX, SS
        shl EAX, 4
        mov BX, offset gdt_stack
        mov [BX].base_1, AX
        shr EAX, 16
        mov [BX].base_m, AL
;Подготовим псевдодескриптор pdescr и загрузим регистр GTR        
        mov dword ptr pdescr+2, EBP         ;(49)База GDT
        mov word ptr pdescr, gdt_size-1     ;(50)Граница GDT
        lgdt pdescr                         ;(51)Загрузим регистр GDTR
;Подготовимся к возврату из защищенного режима в реальный
        ;mov AX, 40h                             ;(52)Настроим ES на область
        ;mov ES, AX                              ;(53)данных BIOS
        ;mov word ptr ES:[67h], offset return    ;(54)Смещение возврата
        ;mov ES:[69h], CS                        ;(55)Сегмент возврата
        ;mov AL, 0Fh                             ;(56)Выборка байта состояния отключения
        ;out 70h, AL                             ;(57)Порт КМОП-микросхемы
        ;mov AL, 0Ah                             ;(58)Установка режима восстановления
        ;out 71h, AL                             ;(59)в регистре 0Fh сброса процессора
        cli                                     ;Запрет аппаратных прерываний
;Переходим в защищенный режим
        mov EAX, CR0                        ;(61)Получим содержимое регистра CR0
        or EAX, 1                           ;(62)Установим бит защищенного режима
        mov CR0, EAX                        ;(63)Запишем назад в CR0

;------------------------------------------------
;Теперь процессор работает в защищенном режиме
;------------------------------------------------

;Загружаем в CS:IP селектор:смещение точки continue
        db 0EAh                             ;(64)Код команды far jmp
        dw offset   continue                ;(65)Смещение
        dw 16                               ;(66)Селектор сегмента команд
continue:
;Делаем адресуемыми данные
        mov AX, 8                           ;(68) Селектор сегмента данных
        mov DS, AX                          
;Делаем адресуемым стек
        mov AX, 24                          ;(70)Селектор сегмента стека
        mov SS, AX
;Инициализируем ES
        mov AX, 32                          ;(72)Селектор сегмента видеобуфера
        mov ES, AX                          ;(73)Инициализируем ES
;Выводим на экран тестовую строку символов
        mov DI, 1920                        ;(74)Начальная позиция на экране
        mov CX, 80                          ;(75)Число выводимых символов
        mov AX, word ptr sym                ;(76)Символ+атрибут
scrn:   stosw                               ;(77)Содержимое AX на экран
        inc AL                              ;(78)Инкремент кода символа
        loop scrn                           ;(79)Цикл вывода
;Вернемся в реальный режим
        ;mov AL, 0FEh                        ;(80)Команда сброса процесссора
        ;out 64h, AL                         ;(81)в порт 64h
        ;hlt                                 ;(82)Останов процессора до оканчания сброса


;Вернемся в реальный режим
;Сформулируем и загрузим дескрипторы для реального режима
        mov gdt_data.lim, 0FFFFh
        mov gdt_code.lim, 0FFFFh
        mov gdt_stack.lim 0FFFFh
        mov gdt_screen.lim 0FFFFh
        push DS
        pop DS
        push SS
        pop SS
        push ES
        pop ES
;Выполним дальнейший переход для того, чтобы заного загрузить селектор
;в регистр CS и модифицировать его теневой регистр
        db 0EAh
        dw offset go 
        dw 16
;Переключим режим процессора
go:     mov EAX, CR0
        and EAX, 0FFFFFFFEh
        mov CR0, EAX         
        db 0EAh
        dw offset return
        dw text

;------------------------------------------------
;Теперь процессор работает в реальном режиме
;------------------------------------------------

return:
;Восстановим вычислительную среду реального режима
        mov AX, data                        ;(84)Сделаем адресуемыми данные
        mov DS, AX
        mov AX, stk                         ;(86)Сделаем адресуемым стек
        mov SS, AX
        mov SP, 256                         ;(88)Настроим SP
        sti                                 ;(89)Разрешим аппаратные прерывания
;Работаем в DOS
        mov AH, 09h                         ;(90)Проверим выполнение функций DOS
        mov DX, offset msg                  ;(91)после возврата в реальный режим
        int 21h
        mov AX, 4C00h                       ;(93)Завершим программу обычным образом
        int 21h
main    endp

code_size=$-main                            ;(96)Размер сегмента команд
text ends

;Сегмент стека
stk     segment stack use16                ;(98)16-разрядный сегмент
        db 256 dup ('^')
stk     ends
        end main